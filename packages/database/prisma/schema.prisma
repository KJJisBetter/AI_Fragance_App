generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String              @id @default(cuid())
  email        String              @unique
  username     String              @unique
  passwordHash String
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  feedbacks    AICategorFeedback[]
  battles      Battle[]
  collections  Collection[]

  @@map("users")
}

model Fragrance {
  id                 String              @id @default(cuid())
  name               String
  brand              String
  year               Int?
  concentration      String?
  topNotes           String[]
  middleNotes        String[]
  baseNotes          String[]
  aiSeasons          String[]
  aiOccasions        String[]
  aiMoods            String[]
  fragranticaSeasons String[]
  communityRating    Float?
  verified           Boolean             @default(false)
  longevity          Int?
  sillage            Int?
  projection         Int?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  feedbacks          AICategorFeedback[]
  battleItems        BattleItem[]
  collections        CollectionItem[]

  @@map("fragrances")
}

model Collection {
  id          String           @id @default(cuid())
  userId      String
  name        String           @default("My Collection")
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  items       CollectionItem[]
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("collections")
}

model CollectionItem {
  id             String     @id @default(cuid())
  collectionId   String
  fragranceId    String
  personalRating Int?
  personalNotes  String?
  purchaseDate   DateTime?
  bottleSize     String?
  createdAt      DateTime   @default(now())
  collection     Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  fragrance      Fragrance  @relation(fields: [fragranceId], references: [id], onDelete: Cascade)

  @@unique([collectionId, fragranceId])
  @@map("collection_items")
}

model Battle {
  id          String       @id @default(cuid())
  userId      String
  title       String
  description String?
  status      BattleStatus @default(ACTIVE)
  createdAt   DateTime     @default(now())
  completedAt DateTime?
  items       BattleItem[]
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("battles")
}

model BattleItem {
  id          String    @id @default(cuid())
  battleId    String
  fragranceId String
  position    Int
  votes       Int       @default(0)
  winner      Boolean   @default(false)
  battle      Battle    @relation(fields: [battleId], references: [id], onDelete: Cascade)
  fragrance   Fragrance @relation(fields: [fragranceId], references: [id], onDelete: Cascade)

  @@unique([battleId, fragranceId])
  @@map("battle_items")
}

model AICategorFeedback {
  id             String    @id @default(cuid())
  userId         String
  fragranceId    String
  aiSuggestion   Json
  userCorrection Json
  feedbackType   String
  createdAt      DateTime  @default(now())
  fragrance      Fragrance @relation(fields: [fragranceId], references: [id], onDelete: Cascade)
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("ai_categor_feedbacks")
}

enum BattleStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}
